---
layout: post
status: publish
published: true
title: "《Python源码剖析》读书笔记：内存垃圾回收"
author:
  display_name: admin
  login: admin
  email: nobody@gmail.com
  url: ''
author_login: admin
author_email: nobody@gmail.com
wordpress_id: 40230
wordpress_url: http://blog.lzhaohao.info/?p=40230
date: '2011-10-27 17:40:17 +0000'
date_gmt: '2011-10-27 09:40:17 +0000'
categories:
- python
tags:
- python
- source
- memory
- garbage collection
comments: []
---
<ul>
<li>Python内存回收的基石是引用计数，&ldquo;当一个对象的引用被创建或复制时，对象的引用技术加1；当一个对象的引用被销毁时，对象的引用技术减1&rdquo;，如果对象的引用计数减少为0，将对象的所占用的内存释放。</li>
<li>引用计数的缺点是对循环引用无能为力，优点是将内存释放的操作时机离散化，不会引起瞬间的大波动。</li>
<li>Python采用Mark-Sweep算法来解决循环引用问题</li>
<li>
<p>Mark-Sweep过程<br />
** 寻找root object集合，root object指全局引用和函数栈上的引用<br />
** 从root object出发，通过其每一个引用到达的所有对象都标记为reachable（垃圾检测）<br />
** 将所有非reachable的对象删除（垃圾回收）</p>
</li>
<li>
<p>垃圾检测只需要跟踪可以保有其他对象引用的container对象（例如list,dict,class,instance等）即可。</p>
</li>
<li>Python创建container对象时，会在前面加入PyGC_Head。通过PyGC_Head串起来的双向链表把所有container对象串起来。</li>
<li>Python的GC有分代机制，分3代。最年轻代到最老代默认个数是700/10/10，当某代里的对象数超过阈值，将会引发一次GC动作。某个对象在一次GC中存活的话，就把它移到更老的一代。</li>
<li>对象的引用计数存在PyGC_Head的ob_refcnt，GC时会使用此值的副本，PyGC_Head的gc.gc_refs</li>
<li>在垃圾检测过程中，会先试探地把所有对象的引用计数减1。遇到一个引用计数为0的对象，先将其标记为GC_TENTATIVELY_UNREACHABLE。如果之后某个对象的遍历过程中遇到这个临时标记的对象，证明它还是有引用的，将其移回reachable列表并且把引用计数设为1。</li>
<li>垃圾检测完成后，所有在unreachable链表的对象都可以释放了，除了那些定义了&#95;&#95;del&#95;&#95;方法的对象。之前一篇<a href="http://blog.lzhaohao.info/archive/the-python-class-which-has-explict-del-method-needs-manually-break-cyclic-reference/">blog</a>也提到，Python不会自动回收这些对象。</li>
</ul>
